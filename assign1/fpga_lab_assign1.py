# -*- coding: utf-8 -*-
"""FPGA_Lab_assign1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BhY4CNimDupx8TiFKaMye4vnJ6qIyCFN
"""

import numpy as np
import matplotlib.pyplot as plt

# Parameters
f = 1000          # Frequency of the sine wave (Hz)
Fs = 48000        # Sampling frequency (Hz)
T = 1             # Duration (sec)
N = Fs * T        # Total number of samples
t = np.arange(0, N) / Fs  # Time vector

# Generate the sine wave
x_t = 2 * np.sin(2 * np.pi * f * t)

# Plot for 5 cycles only
num_cycles = 5
t_plot = np.arange(0, num_cycles / f, 1 / Fs)  # Time for 5 cycles
x_plot = 2 * np.sin(2 * np.pi * f * t_plot)

# Plot the signal
plt.figure()
plt.plot(t_plot, x_plot, 'b', linewidth=1.5)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Sine Wave: 2sin(2π f t), f = 1kHz, Fs = 48kHz')
plt.grid(True)
plt.show()

def fixed_point(x, int_bits, frac_bits):
    scale_factor = 2 ** frac_bits  # Scale up
    total_bits = int_bits + frac_bits  # Total bits (sign included in int_bits)
    max_val = 2 ** (total_bits - 1) - 1  # Max range
    min_val = -2 ** (total_bits - 1)  # Min range

    # Convert to fixed-point integer representation
    x_fixed = np.round(x * scale_factor).astype(int)  # Scale & round
    x_fixed = np.clip(x_fixed, min_val, max_val)  # Clip to avoid overflow

    # Convert to binary (Two’s Complement)
    binary_repr = np.vectorize(lambda num: format(num & (2**total_bits - 1), f'0{total_bits}b'))

    return x_fixed/scale_factor, binary_repr(x_fixed)

print(fixed_point(2.25, 3, 2))  # 3 bits for integer
print(fixed_point(5.75, 4, 2))  # 4 bits for integer
print(fixed_point(4.125, 4, 2))  # 4 bits for integer
print(fixed_point(4.125, 4, 3))  # 4 bits for integer
print(fixed_point(-2.0, 4, 3))  # 4 bits for integer
print(fixed_point(-1.75, 4, 3))  # 4 bits for integer

# As Sin max and min ranges from ± 2, min 3 bits integer(signed included) representation will be better.

x_Q2_14, Q2_14_bin = fixed_point(x_t, 2, 14)
x_Q4_12, Q4_12_bin = fixed_point(x_t, 4, 12)
x_Q8_4, Q8_4_bin  = fixed_point(x_t, 8, 4)

x_Q2_14_plot = x_Q2_14[0:len(x_plot)]
x_Q4_12_plot = x_Q4_12[0:len(x_plot)]
x_Q8_4_plot  = x_Q8_4[0:len(x_plot)]

intrested_region=14

# Plot the original and fixed-point waveforms
plt.figure(figsize=(15, 5))
plt.subplot(1,2,1)
plt.plot(t_plot, x_plot, 'k', label="Original", linewidth=1.5)
plt.plot(t_plot, x_Q2_14_plot, 'ro--', label="Q(2,14)", linewidth=1, markersize=1)
plt.plot(t_plot, x_Q4_12_plot, 'go--', label="Q(4,12)", linewidth=1, markersize=1)
plt.plot(t_plot, x_Q8_4_plot, 'bo--', label="Q(8,4)", linewidth=1, markersize=1)
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.title("Fixed-Point Conversions of 2sin(2πft)")
plt.legend()
plt.grid()

plt.subplot(1,2,2)
plt.scatter(t_plot[0:intrested_region], x_plot[0:intrested_region], color='purple', label="Original", s=10)
plt.scatter(t_plot[0:intrested_region], x_Q2_14_plot[0:intrested_region], color='r', marker='o', linestyle='--', label="Q(2,14)", s=6)
plt.scatter(t_plot[0:intrested_region], x_Q4_12_plot[0:intrested_region], color='g', marker='o', linestyle='--', label="Q(4,12)", s=1)
plt.scatter(t_plot[0:intrested_region], x_Q8_4_plot[0:intrested_region], color='b', marker='o', linestyle='--', label="Q(8,4)", s=1)
plt.xlabel("Time (s)")
plt.ylabel("Amplitude")
plt.title("Zoomed")
plt.legend()
plt.grid()

error_Q2_14 = x_t - x_Q2_14
error_Q4_12 = x_t - x_Q4_12
error_Q8_4 = x_t - x_Q8_4

error_Q2_14_plot = error_Q2_14[0:len(x_plot)]
error_Q4_12_plot = error_Q4_12[0:len(x_plot)]
error_Q8_4_plot  = error_Q8_4[0:len(x_plot)]

x_positions = [1, 2, 3]
mean_errors = [np.abs(error_Q2_14).mean(), np.abs(error_Q4_12).mean(), np.abs(error_Q8_4).mean()]

plt.figure(figsize=(15, 5))
plt.subplot(1,2,1)
plt.plot(t_plot, error_Q2_14_plot, color='r', label="Error (Q2,14)")
plt.plot(t_plot, error_Q4_12_plot, color='g', label="Error (Q4,12)")
plt.plot(t_plot, error_Q8_4_plot, color='b', label="Error (Q8,4)")
plt.xlabel("Time (s)")
plt.ylabel("Error")
plt.title("Fixed-Point Approximation Errors")
plt.legend()
plt.grid()

plt.subplot(1,2,2)
plt.scatter(x_positions, mean_errors, color=['r', 'g', 'b'], s=100)
plt.xticks(x_positions, ["Q(2,14)", "Q(4,12)", "Q(8,4)"])
plt.xlabel("Fixed-Point Format")
plt.ylabel("Mean Error")
plt.title("Mean Quantization Error for Different Fixed-Point Formats")
plt.grid()
plt.show()

mean_errors

signal_power = np.mean(x_t ** 2)
noise_power_Q2_14 = np.mean(error_Q2_14 ** 2)
noise_power_Q4_12 = np.mean(error_Q4_12 ** 2)
noise_power_Q8_4 = np.mean(error_Q8_4 ** 2)

# Compute SQNR for each case
SQNR_Q2_14 = signal_power / noise_power_Q2_14
SQNR_Q4_12 = signal_power / noise_power_Q4_12
SQNR_Q8_4 = signal_power / noise_power_Q8_4

# Convert to decibels (dB)
SQNR_Q2_14_dB = 10 * np.log10(SQNR_Q2_14)
SQNR_Q4_12_dB = 10 * np.log10(SQNR_Q4_12)
SQNR_Q8_4_dB = 10 * np.log10(SQNR_Q8_4)

# Display results
print(f"SQNR for Q(2,14): {SQNR_Q2_14_dB:.2f} dB")
print(f"SQNR for Q(4,12): {SQNR_Q4_12_dB:.2f} dB")
print(f"SQNR for Q(8,4): {SQNR_Q8_4_dB:.2f} dB")

